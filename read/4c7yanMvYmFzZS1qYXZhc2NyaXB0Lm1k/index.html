<!DOCTYPE html ><html lang="zh"><head> <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.8.0/styles/default.min.css"/><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script>window.addEventListener('DOMContentLoaded',()=>{
    hljs.highlightAll();
})</script><style>blockquote{
    margin: 4px;
    border-left: 2px solid var(--Cbrand);
    opacity: .75
}
</style><link rel="icon" href="/files/icon.svg"/><meta charset="utf-8"/><meta name="viewport" content="width:device-width,initial-scale=1.0"/><meta name="author" content="0xarch"/><meta name="description" content="本文写于2024年6月。
JavaScript 入门，总结自 MDN。
包含：函数调用、变量声明的简易阐述。"/><meta name="keywords" content="Web Node.js JavaScript"/><meta http-equiv="content-language" content="zh-CN"/><link rel="stylesheet" href="/files/style.css"/><link rel="stylesheet" href="/files/components/KContentTable.css"/><script src="/files/es/KContentTable.js"></script><link rel="stylesheet" href="/files/components/KFooter.css"/><link rel="stylesheet" href="/files/components/KNextPage.css"/><link rel="stylesheet" href="/files/components/KNavigationBar.css"/><script src="/files/es/KNavigationBar.js"></script><title>JavaScript 基础 :: 文章</title></head><body class="colorful" OCP="OVERRIDE" style="--color1:#36f11b;--color2:#f3ef3e"><header class="KNavigationBar"><a class="kLogo" href="/">0xarch's Blogs</a><button class="kToggle"><svg viewBox="0 0 48 48" fill="none" height="48" stroke="currentColor" stroke-width="2" width="48" xmlns="http://www.w3.org/2000/svg"><path d="M12,14h24M12,24h24M12,34h24"></path></svg></button><div class="kCon"><a href="/">首页</a><a href="/archive/1">归档</a><a href="/category/1">分类</a><a href="/tag/1">标签</a><a href="/about/">关于</a><a href="/status/">状态 </a><a href="/tools/">工具</a></div></header><div class="PageLabel uWcon"><div class="h1">JavaScript 基础</div><b class="meta"><date>2024年6月2日星期日</date><span>Web</span><span>2012字</span></b></div><main class="uWcon"><section><h2>前言</h2><p>本文写于2024年6月。 JavaScript 入门，总结自 MDN。 包含：函数调用、变量声明的简易阐述。</p></section><article id="markdown_fillContent"><h1>JavaScript 基础</h1><h2>JavaScript 特点</h2><p>JavaScript (简称JS/ES，或ECMA Script)， 一种脚本语言。</p><p>你需要一个解释器来运行一个 JS 脚本。</p><h2>注释</h2><p>通过双斜杠或斜杠+星号定义注释。</p><pre><code class="language-js">// Line Comment

/*
Block Comment
Still Comment
*/
</code></pre><h2>关键字</h2><p>以下词语属于 JS 关键字。</p><ul><li>break</li><li>case</li><li>catch</li><li>class</li><li>const</li><li>continue</li><li>debugger</li><li>default</li><li>delete</li><li>do</li><li>else</li><li>export</li><li>extends</li><li>finally</li><li>for</li><li>function</li><li>if</li><li>import</li><li>in</li><li>instanceof</li><li>new</li><li>return</li><li>super</li><li>switch</li><li>this</li><li>throw</li><li>try</li><li>typeof</li><li>var</li><li>void</li><li>while</li><li>with</li><li>yield</li><li>implements</li><li>interface</li><li>let</li><li>package</li><li>private</li><li>protected</li><li>public</li><li>static</li><li>await</li><li>enum (预定)</li></ul><p>以下字符为字面量，同样不能作为标识使用。</p><ul><li>null</li><li>true</li><li>false</li></ul><h2>变量</h2><h3>变量声明和更改的语法</h3><p>JS 中，可以使用 <code>var</code> <code>let</code> <code>const</code> 定义变量，其中使用 <code>const</code> 定义的变量不可变(对象可变)。</p><p>不推荐使用 <code>var</code> 定义变量。</p><p>实例：</p><pre><code class="language-js">let foo = &#39;foo&#39;;
const bar = &#39;bar&#39;;
let arrayVar = [&#39;1&#39;,2,foo];

foo = &#39;bar&#39;; // 修改
</code></pre><h3>如何声明变量</h3><p>通过 JS 内置语法定义基本类型变量。</p><ol><li>字符串</li></ol><p>通过单引号或双引号定义。</p><ol start="2"><li>数组</li></ol><p>通过中括号定义。</p><ol start="3"><li>正则表达式</li></ol><p>通过斜杠定义。</p><ol start="4"><li>对象</li></ol><p>通过花括号定义。</p><ol start="5"><li>类</li></ol><p>通过 <code>new</code> 定义。</p><ol start="6"><li>布尔值</li></ol><p>通过 <code>true</code> 和 <code>false</code> 定义。</p><h4>实例</h4><pre><code class="language-js">let str = &#39;String&#39;;
let arr = [&#39;A&#39;,&#39;r&#39;,&#39;r&#39;,&#39;a&#39;,&#39;y&#39;,1]; // 注意：数组内元素类型可以不一致
let regex = /^(Minecraft\*? .*?)/g;
let obj = {
    a: 1,
    b: &#39;fooBar&#39;
};
let cls = new IntersectionObserver(); // 这个类是 Web API 的一部分，仅在 Web 环境可用。
let boolTrue = true;
</code></pre><h2>函数</h2><p>一般来说，一个函数是可以通过外部代码调用的一个&quot;子程序&quot;（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。在 JavaScript 中，函数是头等 (first-class)对象，因为它们可以像任何其他对象一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。简而言之，它们是 <code>Function</code> 对象。</p><h3>定义函数</h3><h4>function</h4><p>标准的函数定义方式。通过此方式定义的函数具有面向对象的特性。</p><pre><code class="language-js">function someFunction(){
    doSomething();
}
var someFunction2 = function(){
    doSomething();
}
var someFunction3 = function functionName(){
    doSomething();
}
</code></pre><h4>箭头函数</h4><p>标准的函数定义方式。通过此方式定义的函数不具有部分面向对象的特性和部分过时的API;</p><blockquote><p>此定义的函数没有 this , arguments , super 绑定。 不能用作构造函数。 不能作为生成器函数。</p></blockquote><pre><code class="language-js">const someFunction = () =&gt; { 
    doSomething();
}
const someFunction2 = param =&gt; { // param: 零参数需要用 () 表示。只有一个参数时不需要括号。参数部分支持剩余参数、默认参数和解构赋值。
    doSomething(param);
}
</code></pre><h4>new Function</h4><pre><code class="language-js">const fun = new Function(&#39;doSomething()&#39;);
</code></pre><p>不推荐此方式。</p><h3>更改函数</h3><p>通过 <code>function</code> 定义的函数或者非 <code>const</code> 关键字定义的箭头函数可以被更改，就如同变量一样。</p><h3>参数</h3><h4>参数声明和使用</h4><p>在声明函数时可以定义参数的名字，并在函数中直接使用。</p><pre><code class="language-js">function someFunction(arg1,...arg2){
    console.log(arg1,arg2);
}
</code></pre><h5>默认参数</h5><p>函数默认参数允许在没有值或 <code>undefined</code> 被传入时使用默认形参。</p><pre><code class="language-js">function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5, 2));
// Expected output: 10

console.log(multiply(5));
// Expected output: 5
</code></pre><h5>剩余参数</h5><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。此方法可以将函数调用时参数列表末尾所有未被捕捉的参数统合成一个数组，并可以在函数内访问。</p><pre><code class="language-js">function sum(...theArgs) {
  let total = 0;
  for (const arg of theArgs) {
    total += arg;
  }
  return total;
}

console.log(sum(1, 2, 3));
// Expected output: 6

console.log(sum(1, 2, 3, 4));
// Expected output: 10
</code></pre><h5>解构赋值</h5><p>解构赋值语法是一种 JS 表达式。可以将数组中的值或对象的属性取出，赋值给其他变量。</p><pre><code class="language-js">let a, b, rest;
[a, b] = [10, 20];

console.log(a);
// Expected output: 10

console.log(b);
// Expected output: 20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(rest);
// Expected output: Array [30, 40, 50]
</code></pre><h4>使用未声明的参数</h4><p>通过 <code>arguments</code> 对象可以访问传入的所有参数。 <code>arguments</code> 是一个类数组，所以你可以直接用下标来访问。</p><p><strong>注意</strong> 由于剩余参数的引入，已经不建议使用此特性。</p><p><strong>注意</strong> 此特性在箭头函数中不可用。</p><h4>参数引用</h4><p>调用函数时，传递给函数的值被称为函数的实参（值传递），对应位置的函数参数名叫作形参。如果实参是一个包含原始值 (数字，字符串，布尔值) 的变量，则就算函数在内部改变了对应形参的值，返回后，该实参变量的值也不会改变。如果实参是一个对象引用，则对应形参会和该实参指向同一个对象。假如函数在内部改变了对应形参的值，返回后，实参指向的对象的值也会改变。</p><pre><code class="language-js">// 示例来自 MDN
/* 定义函数 myFunc */
function myFunc(theObject) {
  //实参 mycar 和形参 theObject 指向同一个对象。
  theObject.brand = &quot;Toyota&quot;;
}

/*
 * 定义变量 mycar;
 * 创建并初始化一个对象;
 * 将对象的引用赋值给变量 mycar
 */
var mycar = {
  brand: &quot;Honda&quot;,
  model: &quot;Accord&quot;,
  year: 1998,
};

/* 弹出 &#39;Honda&#39; */
window.alert(mycar.brand);

/* 将对象引用传给函数 */
myFunc(mycar);

/*
 * 弹出 &#39;Toyota&#39;,对象的属性已被修改。
 */
console.log(mycar.brand);
</code></pre><h4>回调函数作为参数</h4><p>回调函数可以作为参数的一部分传入函数，并在适当时机被执行。</p><blockquote><p>回调可以通过两种方式进行调用：同步和异步。同步回调在外部函数调用后立即调用，没有中间的异步任务；异步回调在某个稍后的时间点调用，通常是在一个异步操作完成后。</p></blockquote><p>回调函数可以直接在参数列表中定义，箭头函数同样可以作为回调函数。</p><p>JS 执行器并不关心调用回调函数时传入变量的名字。</p><pre><code class="language-js">function foo(arg1){
    arg1(&#39;the argument&#39;);
}
function bar(arg1){
    console.log(&#39;调用了预先定义的回调函数，传入参数:&#39;,arg1);
}

foo(bar);
foo(param =&gt; {
    console.log(&#39;调用了直接定义的回调函数，传入参数:&#39;,param)
})
</code></pre><h3>返回值</h3><p>使用 <code>return</code> 关键字可以中断函数执行并返回一个值，此值作为函数的值，因此可以直接使用 <code>a=b()</code> 这类语法。</p><h2>对象和原型链</h2><p>JavaScript 只有一种结构：对象。每个对象（object）都有一个私有属性指向另一个名为原型（prototype）的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为 null。根据定义，null 没有原型，并作为这个原型链（prototype chain）中的最后一个环节。可以改变原型链中的任何成员，甚至可以在运行时换出原型。</p><h3>属性继承</h3><p>JavaScript 对象是动态的属性（指其自有属性）“包”。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><h3>构造函数</h3><p>如果一组属性应该出现在每一个实例上，那我们就可以重用它们——尤其是对于方法。</p><pre><code class="language-js">const boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];
</code></pre><p>我们可以将 <code>getValue</code> 移动到所有盒子的 <code>[[Prototype]]</code> 上：</p><pre><code class="language-js">const boxPrototype = {
  getValue() {
    return this.value;
  },
};

const boxes = [
  { value: 1, __proto__: boxPrototype },
  { value: 2, __proto__: boxPrototype },
  { value: 3, __proto__: boxPrototype },
];
</code></pre><p>使用构造函数简化代码：</p><pre><code class="language-js">// 一个构造函数
function Box(value) {
  this.value = value;
}

// 使用 Box() 构造函数创建的所有盒子都将具有的属性
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];
</code></pre><p>重写为类：</p><pre><code class="language-js">class Box {
  constructor(value) {
    this.value = value;
  }

  // 在 Box.prototype 上创建方法
  getValue() {
    return this.value;
  }
}
</code></pre><p>类是构造函数的语法糖，这意味着你仍然可以修改 Box.prototype 来改变所有实例的行为。</p><h4>字面量的隐式构造函数</h4><pre><code class="language-js">// 对象字面量（没有 `__proto__` 键）自动将
// `Object.prototype` 作为它们的 `[[Prototype]]`
const object = { a: 1 };
Object.getPrototypeOf(object) === Object.prototype; // true

// 数组字面量自动将 `Array.prototype` 作为它们的 `[[Prototype]]`
const array = [1, 2, 3];
Object.getPrototypeOf(array) === Array.prototype; // true

// 正则表达式字面量自动将 `RegExp.prototype` 作为它们的 `[[Prototype]]`
const regexp = /abc/;
Object.getPrototypeOf(regexp) === RegExp.prototype; // true
</code></pre><p>我们可以将它们“解糖（de-sugar）”为构造函数形式。</p><pre><code class="language-js">const array = new Array(1, 2, 3);
const regexp = new RegExp(&quot;abc&quot;);
</code></pre></article><hr/><div class="fit cclogo"><a href="https://creativecommons.org/">传播许可协议</a><div class="inner"><b>Creative Commons </b><span>BY</span><span>NC</span><span>SA</span></div></div><br/><div class="KNextPage"><a class="arrow left nowrap disabled">← 已是最新</a><a class="arrow right nowrap" href="/read/4c7lZmV3dS9zaW1wbHVzLXRoZW1lLm1k/">simplus主题源码概述 →</a><a class="top" href="#">Top</a></div></main><hr/><footer class="KFooter uWcon"><div class="kLinks"><nav><h3>Project Fivewu</h3><span>Fewu Generator </span><span>1.2.3</span><a href="https://github.com/0xarch/fewu">Source Code</a></nav><nav><h3>Simplus</h3><span>2.0.0</span><a href="https://github.com/0xarch/fewu-theme-simplus">Github</a></nav><nav><h3>Contact</h3><a href="https://0xarch.github.io">Github Page</a><a href="https://matrix.to/#/#solo_esta_vez:mozilla.org">[Matrix] Moz</a><a href="https://matrix.to/#/#solo_esta_vez:fedora.im">[Matrix] Fedora</a><a href="mailto:alanqa-ops@outlook.com">E-Mail</a></nav><nav><h3>Friends</h3><a href="https://wangyuzhen666.github.io">Wyz666</a></nav></div><br/><hr/><div class="kCopyr tac">2024 Powered by Fewu. 2020-2024 0xarch,soloev All rights reserved.</div></footer><div class="KContentTable"><div class="kTOC"></div><br/><button class="kButton">TOC</button></div></body></html>