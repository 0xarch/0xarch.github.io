<!DOCTYPE html ><html lang="zh"><head> <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.8.0/styles/default.min.css"/><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script>window.addEventListener('DOMContentLoaded',()=>{
    hljs.highlightAll();
})</script><style>blockquote{
    margin: 4px;
    border-left: 2px solid var(--Cbrand);
    opacity: .75
}
</style><link rel="icon" href="/files/icon.svg"/><meta charset="utf-8"/><meta name="viewport" content="width:device-width,initial-scale=1.0"/><meta name="author" content="0xarch"/><meta name="description" content="本文写于2024年6月。
JavaScript 入门，转载并总结自 MDN。
包含：函数调用、变量声明的简易阐述。"/><meta name="keywords" content="Web Node.js JavaScript"/><meta http-equiv="content-language" content="zh-CN"/><link rel="stylesheet" href="/files/style.css"/><link rel="stylesheet" href="/files/components/KContentTable.css"/><script src="/files/es/KContentTable.js"></script><link rel="stylesheet" href="/files/components/KFooter.css"/><link rel="stylesheet" href="/files/components/KNextPage.css"/><link rel="stylesheet" href="/files/components/KNavigationBar.css"/><script src="/files/es/KNavigationBar.js"></script><title>JavaScript 基础 :: 文章</title></head><body class="colorful" OCP="OVERRIDE" style="--color1:#32feef;--color2:#fefc13"><header class="KNavigationBar"><a class="kLogo" href="/">0xarch's Blogs</a><button class="kToggle"><svg viewBox="0 0 48 48" fill="none" height="48" stroke="currentColor" stroke-width="2" width="48" xmlns="http://www.w3.org/2000/svg"><path d="M12,14h24M12,24h24M12,34h24"></path></svg></button><div class="kCon"><a href="/">首页</a><a href="/archive/1">归档</a><a href="/category/1">分类</a><a href="/tag/1">标签</a><a href="/about/">关于</a><a href="/status/">状态 </a><a href="/tools/">工具</a></div></header><div class="PageLabel uWcon"><div class="h1">JavaScript 基础</div><b class="meta"><date>2024年6月2日星期日</date><span>Web</span><span>2965字</span></b></div><main class="uWcon"><section><h2>前言</h2><p>本文写于2024年6月。 JavaScript 入门，转载并总结自 MDN。 包含：函数调用、变量声明的简易阐述。</p></section><article id="markdown_fillContent"><h1>JavaScript 基础</h1><h2>概览和导航</h2><p>由于篇幅过长，JS基础将分篇上传。</p><p><a href="../../../../2024/6/3/js:base-js-2-obj_and_proto.md">对象和原型链</a></p><p>JavaScript (简称JS/ES，或ECMA Script)， 一种脚本语言。</p><p>你需要一个解释器来运行一个 JS 脚本。</p><h2>注释</h2><p>通过双斜杠定义行注释。</p><p>通过斜杠+星号定义块注释。</p><pre><code class="language-js">// Line Comment

/*
Block Comment
Block line 2
*/
</code></pre><h3>JSDoc</h3><p>非标准拓展语法，以斜杠+双星号开头，用于标识对象。</p><pre><code class="language-js">/**
 * This is JSDoc
 * @param {string} arg1
 * @param {number[]} args
 * @returns {string}
*/
function markedByJSDoc(arg1,...args){
  return &#39;2&#39;;
}
</code></pre><h2>关键字</h2><p>以下词语属于 JS 关键字。</p><ul><li>break</li><li>case</li><li>catch</li><li>class</li><li>const</li><li>continue</li><li>debugger</li><li>default</li><li>delete</li><li>do</li><li>else</li><li>export</li><li>extends</li><li>finally</li><li>for</li><li>function</li><li>if</li><li>import</li><li>in</li><li>instanceof</li><li>new</li><li>return</li><li>super</li><li>switch</li><li>this</li><li>throw</li><li>try</li><li>typeof</li><li>var</li><li>void</li><li>while</li><li>with</li><li>yield</li><li>implements</li><li>interface</li><li>let</li><li>package</li><li>private</li><li>protected</li><li>public</li><li>static</li><li>await</li><li>enum (预定)</li></ul><p>以下字符为字面量，同样不能作为标识使用。</p><ul><li>null</li><li>true</li><li>false</li></ul><h2>变量</h2><h3>变量声明和更改</h3><p>JS 中，可以使用 <code>var</code> <code>let</code> <code>const</code> 定义变量，其中使用 <code>const</code> 定义的变量不可变(对象可变)。</p><p>不推荐使用 <code>var</code> 定义变量。</p><p>实例：</p><pre><code class="language-js">var someNumber = 0;
let foo = &#39;foo&#39;;
const bar = &#39;bar&#39;;
let arrayVar = [&#39;1&#39;,2,foo];

foo = &#39;bar&#39;; // 修改
someNumber = 1;
var someNumber = 2;
</code></pre><p>通过 <code>var</code> 声明的变量可以再次用 <code>var</code> 覆盖。但是 <code>let</code> 和 <code>const</code> 则不具备此特性。下面的示例会抛出错误：</p><pre><code class="language-js">let foo = &#39;foo&#39;;
let foo = &#39;bar&#39;;
</code></pre><h3>声明变量、JavaScript 字面量</h3><p>通过 JS 内置语法定义基本类型变量。</p><ol><li>字符串</li></ol><p>通过单引号或双引号定义。</p><ol start="2"><li>数组</li></ol><p>通过中括号定义。</p><ol start="3"><li>正则表达式</li></ol><p>通过斜杠定义。</p><ol start="4"><li>对象</li></ol><p>通过花括号定义。</p><ol start="5"><li>类</li></ol><p>通过 <code>new</code> 定义。</p><ol start="6"><li>布尔值</li></ol><p>通过 <code>true</code> 和 <code>false</code> 定义。</p><h4>实例</h4><pre><code class="language-js">let str = &#39;String&#39;;
let arr = [&#39;A&#39;,&#39;r&#39;,&#39;r&#39;,&#39;a&#39;,&#39;y&#39;,1]; // 注意：数组内元素类型可以不一致
let regex = /^(Minecraft\*? .*?)/g;
let obj = {
    a: 1,
    b: &#39;fooBar&#39;
};
let cls = new IntersectionObserver(); // 这个类是 Web API 的一部分，仅在 Web 环境可用。
let boolTrue = true;
</code></pre><h2>函数</h2><p>一般来说，一个函数是可以通过外部代码调用的一个&quot;子程序&quot;（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。在 JavaScript 中，函数是头等对象，因为它们可以像任何其他对象一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。简而言之，它们是 <code>Function</code> 对象。</p><h3>定义函数</h3><h4>function</h4><p>标准的函数定义方式。通过此方式定义的函数具有面向对象的特性。</p><pre><code class="language-js">function someFunction(){
    doSomething();
}
var someFunction2 = function(){
    doSomething();
}
var someFunction3 = function functionName(){
    doSomething();
}
</code></pre><h4>箭头函数</h4><p>标准的函数定义方式。通过此方式定义的函数不具有部分面向对象的特性和部分过时的API;</p><blockquote><p>此定义的函数没有 this , arguments , super 绑定。 不能用作构造函数。 不能作为生成器函数。</p></blockquote><pre><code class="language-js">const someFunction = () =&gt; { 
    doSomething();
}
const someFunction2 = param =&gt; { // param: 零参数需要用 () 表示。只有一个参数时不需要括号。参数部分支持剩余参数、默认参数和解构赋值。
    doSomething(param);
}
</code></pre><h4>new Function</h4><pre><code class="language-js">const fun = new Function(&#39;doSomething()&#39;);
</code></pre><p>不推荐此方式。</p><h3>更改函数</h3><p>通过 <code>function</code> 定义的函数或者非 <code>const</code> 关键字定义的箭头函数可以被更改，就如同变量一样。</p><h3>参数</h3><h4>参数声明和使用</h4><p>在声明函数时可以定义参数的名字，并在函数中直接使用。</p><pre><code class="language-js">function someFunction(arg1,...arg2){
    console.log(arg1,arg2);
}
</code></pre><h5>默认参数</h5><p>函数默认参数允许在没有值或 <code>undefined</code> 被传入时使用默认形参。</p><pre><code class="language-js">function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5, 2));
// Expected output: 10

console.log(multiply(5));
// Expected output: 5
</code></pre><h5>剩余参数</h5><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。此方法可以将函数调用时参数列表末尾所有未被捕捉的参数统合成一个数组，并可以在函数内访问。</p><pre><code class="language-js">function sum(...theArgs) {
  let total = 0;
  for (const arg of theArgs) {
    total += arg;
  }
  return total;
}

console.log(sum(1, 2, 3));
// Expected output: 6

console.log(sum(1, 2, 3, 4));
// Expected output: 10
</code></pre><h5>解构赋值</h5><p>解构赋值语法是一种 JS 表达式。可以将数组中的值或对象的属性取出，赋值给其他变量。</p><pre><code class="language-js">let a, b, rest;
[a, b] = [10, 20];

console.log(a);
// Expected output: 10

console.log(b);
// Expected output: 20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(rest);
// Expected output: Array [30, 40, 50]
</code></pre><h4>使用未声明的参数</h4><p>通过 <code>arguments</code> 对象可以访问传入的所有参数。 <code>arguments</code> 是一个类数组，所以你可以直接用下标来访问。</p><p><strong>注意</strong> 由于剩余参数的引入，已经不建议使用此特性。</p><p><strong>注意</strong> 此特性在箭头函数中不可用。</p><h4>参数引用</h4><p>调用函数时，传递给函数的值被称为函数的实参（值传递），对应位置的函数参数名叫作形参。如果实参是一个包含原始值 (数字，字符串，布尔值) 的变量，则就算函数在内部改变了对应形参的值，返回后，该实参变量的值也不会改变。如果实参是一个对象引用，则对应形参会和该实参指向同一个对象。假如函数在内部改变了对应形参的值，返回后，实参指向的对象的值也会改变。</p><pre><code class="language-js">// 示例来自 MDN
/* 定义函数 myFunc */
function myFunc(theObject) {
  //实参 mycar 和形参 theObject 指向同一个对象。
  theObject.brand = &quot;Toyota&quot;;
}

/*
 * 定义变量 mycar;
 * 创建并初始化一个对象;
 * 将对象的引用赋值给变量 mycar
 */
var mycar = {
  brand: &quot;Honda&quot;,
  model: &quot;Accord&quot;,
  year: 1998,
};

/* 弹出 &#39;Honda&#39; */
window.alert(mycar.brand);

/* 将对象引用传给函数 */
myFunc(mycar);

/*
 * 弹出 &#39;Toyota&#39;,对象的属性已被修改。
 */
console.log(mycar.brand);
</code></pre><h4>回调函数作为参数</h4><p>回调函数可以作为参数的一部分传入函数，并在适当时机被执行。</p><blockquote><p>回调可以通过两种方式进行调用：同步和异步。同步回调在外部函数调用后立即调用，没有中间的异步任务；异步回调在某个稍后的时间点调用，通常是在一个异步操作完成后。</p></blockquote><p>回调函数可以直接在参数列表中定义，箭头函数同样可以作为回调函数。</p><p>JS 执行器并不关心调用回调函数时传入变量的名字。</p><pre><code class="language-js">function foo(arg1){
    arg1(&#39;the argument&#39;);
}
function bar(arg1){
    console.log(&#39;调用了预先定义的回调函数，传入参数:&#39;,arg1);
}

foo(bar);
foo(param =&gt; {
    console.log(&#39;调用了直接定义的回调函数，传入参数:&#39;,param)
})
</code></pre><h3>返回值</h3><p>使用 <code>return</code> 关键字可以中断函数执行并返回一个值，此值作为函数的值，因此可以直接使用 <code>a=b()</code> 这类语法。</p><h2>逻辑语句</h2><h3>条件和分支</h3><h4>if...[else...]</h4><p>当指定条件为真，if 语句会执行一段语句。如果条件为假，则执行另一段语句。</p><p>多层 <code>if...else</code> 语句可使用 <code>else if</code> 从句。注意：在 JavaScript 中没有 <code>elseif</code> （一个单词）关键字。</p><p>要在一个从句中执行多条语句，可使用语句块（{ ... }）。</p><h5>语法</h5><pre><code>if (condition)
   statement1
[else
   statement2]
</code></pre><pre><code>if (condition1)
   statement1
else if (condition2) {
   statements2
} else if (condition3) {
   statements3
} ...
else
   statementN
</code></pre><h5>示例</h5><pre><code class="language-js">function testNum(a) {
  let result;
  if (a &gt; 0) {
    result = &#39;positive&#39;;
  } else {
    result = &#39;NOT positive&#39;;
  }
  return result;
}

console.log(testNum(-5));
// Expected output: &quot;NOT positive&quot;
</code></pre><h5>注意</h5><p>不要将原始布尔值的true和false与Boolean对象的真或假混淆。任何一个值，只要它不是 undefined、null、 0、NaN或空字符串（&quot;&quot;），那么无论是任何对象，即使是值为假的 <code>Boolean</code> 对象，在条件语句中都为真。</p><pre><code class="language-js">var b = new Boolean(false);
if (b) //表达式的值为 true
</code></pre><p>建议不要在条件表达式中单纯的使用赋值运算，因为粗看下赋值运算的代码很容易让人误认为是等性比较。<br>如果你需要在条件表达式中使用赋值运算，用圆括号包裹赋值运算。</p><pre><code class="language-js">if ((x = y)) {
  /* do the right thing */
}
</code></pre><h4>switch</h4><p><code>switch</code> 语句会对一个表达式求值，并将表达式的值与一系列 <code>case</code> 子句进行匹配，一旦遇到与表达式值相匹配的第一个 <code>case</code> 子句后，将执行该子句后面的语句，直到遇到 <code>break</code> 语句为止。若没有 <code>case</code> 子句与表达式的值匹配，如果没有任何 <code>case</code> 子句与表达式的值匹配，则会跳转至 <code>switch</code> 语句的 <code>default</code> 子句执行。</p><h5>语法</h5><pre><code class="language-js">switch (expression) {
  case caseExpression1:
    statements
  case caseExpression2:
    statements
  // …
  case caseExpressionN:
    statements
  default: // Optional
    statements
}
</code></pre><h5>示例</h5><pre><code class="language-js">const expr = &#39;Papayas&#39;;
switch (expr) {
  case &#39;Oranges&#39;:
    console.log(&#39;Oranges are $0.59 a pound.&#39;);
    break;
  case &#39;Mangoes&#39;:
  case &#39;Papayas&#39;:
    console.log(&#39;Mangoes and papayas are $2.79 a pound.&#39;);
    // Expected output: &quot;Mangoes and papayas are $2.79 a pound.&quot;
    break;
  default:
    console.log(`Sorry, we are out of ${expr}.`);
}
</code></pre><h5>跳出和穿透</h5><p>你可以在 <code>switch</code> 语句体内部使用 <code>break</code> 语句提前跳出，通常是在执行完两个 <code>case</code> 子句之间的所有语句后。执行会从 <code>switch</code> 语句后的第一条语句继续进行。</p><p>如果省略了 <code>break</code> 语句，程序执行将会继续流向下一个 <code>case</code> 子句，甚至到达 <code>default</code> 子句，而不论该子句中的表达式值是否匹配。这种行为被称为穿透。</p><pre><code class="language-js">// 示例来自 MDN
const foo = 0;
switch (foo) {
  case -1:
    console.log(&quot;负 1&quot;);
    break;
  case 0: // foo 的值匹配这个条件；执行从这里开始
    console.log(0);
  // 忘记了 break！执行穿透
  case 1: // &#39;case 0:&#39; 中没有 break 语句，所以这个 case 也会执行
    console.log(1);
    break; // 遇到 break，不会继续到 &#39;case 2:&#39;
  case 2:
    console.log(2);
    break;
  default:
    console.log(&quot;default&quot;);
}
// 输出 0 和 1
</code></pre><p>在合适的上下文中，其他控制流语句同样具有跳出 <code>switch</code> 语句的效果。例如，如果 <code>switch</code> 语句嵌套在一个函数内部，那么 <code>return</code> 语句将结束函数体的执行，因此也会结束 <code>switch</code> 语句的执行。如果 <code>switch</code> 语句位于循环体内，那么 <code>continue</code> 语句会停止 <code>switch</code> 语句的执行，并跳转到循环体的下一次迭代。</p><h6>利用</h6><p>如果在某个 <code>case</code> 子句下方没有 <code>break</code> 语句，那么无论该 <code>case</code> 子句是否满足条件，程序都会继续执行下一个 <code>case</code> 子句。</p><pre><code class="language-js">const Animal = &quot;长颈鹿&quot;;
switch (Animal) {
  case &quot;奶牛&quot;:
  case &quot;长颈鹿&quot;:
  case &quot;狗&quot;:
  case &quot;猪&quot;:
    console.log(&quot;这类动物没有灭绝。&quot;);
    break;
  case &quot;恐龙&quot;:
  default:
    console.log(&quot;这类动物已经灭绝。&quot;);
}
const Animal = &quot;长颈鹿&quot;;
switch (Animal) {
  case &quot;奶牛&quot;:
  case &quot;长颈鹿&quot;:
  case &quot;狗&quot;:
  case &quot;猪&quot;:
    console.log(&quot;这类动物没有灭绝。&quot;);
    break;
  case &quot;恐龙&quot;:
  default:
    console.log(&quot;这类动物已经灭绝。&quot;);
}
</code></pre><h5>作用域</h5><p><code>case</code> 和 <code>default</code> 子句指示了控制流可能跳转到的位置。然而，它们本身并不创建词法作用域（也不会自动跳出——如上所述所示）。 简单来说，<code>switch</code>内部仅有一个作用域。例如，下面的代码会抛出错误：</p><pre><code class="language-js">const action = &quot;说你好&quot;;
switch (action) {
  case &quot;说你好&quot;:
    const message = &quot;你好&quot;;
    console.log(message);
    break;
  case &quot;说嘿&quot;:
    const message = &quot;嘿&quot;; // Uncaught SyntaxError: Identifier &#39;message&#39; has already been declared
    console.log(message);
    break;
  default:
    console.log(&quot;action 的声明为空。&quot;);
}
</code></pre><p>要修复这个问题，当你需要在 case 子句中使用 let 或 const 声明时，请将其包裹在一个代码块中。</p><h5>default</h5><p>如果没有找到匹配项，将从 <code>default</code> 字句开始执行，并执行该子句之后的所有语句。因此，你可以将 <code>default</code> 置于两个 <code>case</code> 之间。</p><pre><code class="language-js">const foo = 5;
switch (foo) {
  case 2:
    console.log(2);
    break; // 由于遇到了 break，因此不会继续执行 &#39;default:&#39;
  default:
    console.log(&quot;default&quot;);
  // 穿透
  case 1:
    console.log(&quot;1&quot;);
}
</code></pre><p>即使将 <code>default</code> 子句放在所有其他 <code>case</code> 子句之前也可以实现相同的效果。</p><h5>利用：替代 if else 链</h5><p>你可能经常会遇到需要使用一系列 <code>if...else</code> 条件判断的情况。</p><pre><code class="language-js">if (&quot;fetch&quot; in globalThis) {
  // 使用 fetch 获取资源。
} else if (&quot;XMLHttpRequest&quot; in globalThis) {
  // 使用 XMLHttpRequest 获取资源。
} else {
  // 使用自定义 AJAX 逻辑获取资源
}

// 这种模式并非在执行一系列 === 等值比较操作，但仍然可以将其转换为 switch 结构来实现。

switch (true) {
  case &quot;fetch&quot; in globalThis:
    // 使用 fetch 获取资源。
    break;
  case &quot;XMLHttpRequest&quot; in globalThis:
    // 使用 XMLHttpRequest 获取资源。
    break;
  default:
    // 使用自定义 AJAX 逻辑获取资源
    break;
}
</code></pre><p>可以通过这种转换来合理利用 <code>switch</code> 的穿透特性。</p><pre><code class="language-js">switch (true) {
  case isSquare(shape):
    console.log(&quot;该形状是一个正方形。&quot;);
  // 失败，因为正方形也是矩形的一种！
  case isRectangle(shape):
    console.log(&quot;该形状是一个矩形。&quot;);
  case isQuadrilateral(shape):
    console.log(&quot;该形状是一个四边形。&quot;);
    break;
  case isCircle(shape):
    console.log(&quot;该形状是一个圆形。&quot;);
    break;
}
</code></pre></article><hr/><div class="fit cclogo"><a href="https://creativecommons.org/">传播许可协议</a><div class="inner"><b>Creative Commons </b><span>BY</span><span>NC</span><span>SA</span></div></div><br/><div class="KNextPage"><a class="arrow left nowrap" href="/read/2024/6/3/js:base-js-2-obj_and_proto.md/">← JS基础II:对象和原型</a><a class="arrow right nowrap" href="/read/2024/4/9/fewu:simplus-theme.md/">simplus主题源码概述 →</a><a class="top" href="#">Top</a></div></main><hr/><footer class="KFooter uWcon"><div class="kLinks"><nav><h3>Project Fivewu</h3><span>Fewu Generator </span><span>1.2.3</span><a href="https://github.com/0xarch/fewu">Source Code</a></nav><nav><h3>Simplus</h3><span>2.0.0</span><a href="https://github.com/0xarch/fewu-theme-simplus">Github</a></nav><nav><h3>Contact</h3><a href="https://0xarch.github.io">Github Page</a><a href="https://matrix.to/#/#solo_esta_vez:mozilla.org">[Matrix] Moz</a><a href="https://matrix.to/#/#solo_esta_vez:fedora.im">[Matrix] Fedora</a><a href="mailto:alanqa-ops@outlook.com">E-Mail</a></nav><nav><h3>Friends</h3><a href="https://wangyuzhen666.github.io">Wyz666</a></nav></div><br/><hr/><div class="kCopyr tac">2024 Powered by Fewu. 2020-2024 0xarch,soloev All rights reserved.</div></footer><div class="KContentTable"><div class="kTOC"></div><br/><button class="kButton">TOC</button></div></body></html>